<?php

/**
 * Manages the locale currently set for the site.
 *
 * @package Babble
 * @since Alpha 1
 */
class Babble_Locale {
	
	/**
	 * A regex to get the language code prefix from
	 * a URL.
	 *
	 * @var string
	 **/
	protected $lang_regex = '|^[^/]+|i';

	/**
	 * The language for the current request.
	 *
	 * @var string
	 **/
	protected $lang;

	/**
	 * The URL prefix for the current request
	 *
	 * @var string
	 **/
	protected $url_prefix;
	
	/**
	 * A simple flag to stop infinite recursion in various places.
	 *
	 * @var boolean
	 **/
	protected $no_recursion;
	
	/**
	 * The languages that we've switched to, in order.
	 *
	 * @var array
	 **/
	protected $lang_stack;
	
	/**
	 * The current version for purposes of rewrite rules, any 
	 * DB updates, cache busting, etc
	 *
	 * @var int
	 **/
	protected $version = 1;
	
	/**
	 * Setup any add_action or add_filter calls. Initiate properties.
	 *
	 * @return void
	 **/
	function __construct() {
		add_action( 'admin_init', array( & $this, 'admin_init' ) );
		add_action( 'admin_notices', array( & $this, 'admin_notices' ) );
		add_action( 'parse_request', array( & $this, 'parse_request_early' ), 0 );
		add_action( 'pre_comment_on_post', array( & $this, 'pre_comment_on_post' ) );
		add_filter( 'body_class', array( & $this, 'body_class' ) );
		add_filter( 'locale', array( & $this, 'set_locale' ) );
		add_filter( 'mod_rewrite_rules', array( & $this, 'mod_rewrite_rules' ) );
		add_filter( 'post_class', array( & $this, 'post_class' ), null, 3 );
		add_filter( 'pre_update_option_rewrite_rules', array( & $this, 'internal_rewrite_rules_filter' ) );
		add_filter( 'query_vars', array( & $this, 'query_vars' ) );
	}

	/**
	 * Hooks the WP admin_init action 
	 *
	 * @return void
	 **/
	public function admin_init(  ) {
		add_filter( 'home_url', array( & $this, 'home_url' ), null, 2 );
		$this->maybe_update();
	}

	/**
	 * Hooks the WP admin_notices action to warn the admin
	 * if the permalinks aren't pretty enough.
	 *
	 * @return void
	 **/
	public function admin_notices() {
		if ( ! get_option( 'permalink_structure' ) ) {
			printf( '<div class="error"><p>%s</p></div>', __( '<strong>Babble problem:</strong> Fancy permalinks are disabled. Please enable them in order to have language prefixed URLs work correctly.', 'babble' ) );
		}
	}

	/**
	 * Ensure we keep the standard WP rewrite rules.
	 *
	 * @param string $rules The mod_rewrite rules block generated by WP 
	 * @return string A mod_rewrite rules block
	 **/
	public function mod_rewrite_rules( $rules ) {
		global $wp_rewrite, $wp_query;
		if ( $this->no_recursion )
			return $rules;
		$this->no_recursion = true;
		// We need the WP_Rewrite mod_rewrite_rules method to run
		// home_url without a lang query var set, or it generates 
		// an inaccurate RewriteBase and last RewriteRule.
		remove_filter( 'home_url', array( & $this, 'home_url' ), null, 2 );
		$rules = $wp_rewrite->mod_rewrite_rules();
		add_filter( 'home_url', array( & $this, 'home_url' ), null, 2 );
		$this->no_recursion = false;
		return $rules;
	}
	
	/**
	 * Hooks the WP pre_update_option_rewrite_rules filter to add
	 * the prefix to the rewrite rule regexes to deal with the
	 * virtual language dir.
	 * 
	 * @param array $langs The language codes
	 * @return array An array of language codes utilised for this site. 
	 **/
	public function internal_rewrite_rules_filter( $rules ){
		// Add a prefix to the URL to pick up the virtual sub-dir specifying
		// the language. The redirect portion can and should remain perfectly
		// ignorant of it though, as we change it in parse_request.
	    foreach( (array) $rules as $regex => $query )
			$new_rules[ '[a-zA-Z_]+/' . $regex ] = $query;
	    return $new_rules;
	}

	/**
	 * Hooks the WP locale filter to switch locales whenever we gosh darned want.
	 *
	 * @param string $locale The locale 
	 * @return string The locale
	 **/
	public function set_locale( $locale ) {
		global $wp_rewrite, $bbl_languages;
		
		// Deal with the special case of wp-comments-post.php
		if ( false !== stristr( $_SERVER[ 'REQUEST_URI' ], 'wp-comments-post.php' ) ) {
			if ( $comment_post_ID = ( isset( $_POST[ 'comment_post_ID' ] ) ) ? (int) $_POST[ 'comment_post_ID' ] : false ) {
				$this->set_lang( bbl_get_post_lang_code( $comment_post_ID ) );
				return $this->lang;
			}
		}
		
		if ( isset( $this->lang ) )
			return $this->lang;
		if ( is_admin() ) {
			$current_user = wp_get_current_user();
			// @FIXME: At this point a mischievous XSS "attack" could set a user's admin area language for them
			if ( isset( $_GET[ 'lang' ] ) ) {
				$this->set_lang( $_GET[ 'lang' ] );
			} else {
				if ( $lang = get_user_meta( $current_user->ID, 'bbl_admin_lang', true ) ) {
					$this->set_lang( $lang );
				}
			}
		} else { // Front end
			// @FIXME: Should probably check the available languages here
			// @FIXME: Deal with converting /de/ to retrieve the de_DE.mo, this may mean holding $locale (e.g. "de_DE") and $lang (e.g. "de") separately

			if ( preg_match( $this->lang_regex, $this->get_request_string(), $matches ) )
				$this->set_lang_from_prefix( $matches[ 0 ] );
		}
		// So we haven't recognised this language, redirect to the request URI
		// in the default language.
		if ( ! $this->lang ) {
			if ( ! preg_match( '|^/[^/]+/(.*)?|', $_SERVER[ 'REQUEST_URI' ], $matches ) )
				return;
			bbl_switch_to_lang( bbl_get_default_lang_code() );
			// Annoyingly, the home_url filter may not be set here…
			add_filter( 'home_url', array( $this, 'home_url' ), null, 2 );
			$location = trailingslashit( home_url( $matches[ 1 ] ) );
			bbl_restore_lang();
			// Non-permanent redirect as we might add this language in the 
			// future, so don't want agents storing the redirect.
			wp_redirect( $location, 302 );
			exit; // You shall not pass (redirection just above, so shouldn't be reached)
		}
		// Save for logged in users
		// @FIXME: Possible additional DB queries here?
		if ( is_user_logged_in() && $current_user = wp_get_current_user() ) {
			// @TODO: Don't set languages off of 404 requests, if the request comes
			// from a logged in admin, it'll reset their language (which 
			// is annoying). The problem is that we are so early at this point
			// that we can't tell if it's a 404. :(
			update_user_meta( $current_user->ID, 'bbl_admin_lang', $this->lang );
		}
		if ( ! isset( $this->lang ) )
			$this->set_lang( bbl_get_default_lang_code() );
		return $this->lang;
	}

	/**
	 * Hooks the WP parse_request action 
	 *
	 * FIXME: Should I be extending and replacing the WP class?
	 *
	 * @param object $wp WP object, passed by reference (so no need to return)
	 * @return void
	 **/
	public function parse_request_early( $wp ) {
		// If this is the site root, redirect to default language homepage 
		if ( ! $wp->request ) {
			remove_filter( 'home_url', array( $this, 'home_url' ), null, 2 );
			wp_redirect( home_url( bbl_get_default_lang_url_prefix() ) );
			add_filter( 'home_url', array( $this, 'home_url' ), null, 2 );
			exit;
		}
		// Otherwise, simply set the lang for this request
		$wp->query_vars[ 'lang' ] = $this->lang;
		$wp->query_vars[ 'lang_url_prefix' ] = $this->url_prefix;
	}

	/**
	 * Hooks the WP query_vars filter to add the home_url filter.
	 *
	 * @param array $query_vars An array of the public query vars 
	 * @return array An array of the public query vars
	 **/
	public function query_vars( $query_vars ) {
		add_filter( 'home_url', array( $this, 'home_url' ), null, 2 );
		return array_merge( $query_vars, array( 'lang', 'lang_url_prefix' ) );
	}

	/**
	 * Hooks the WP pre_comment_on_post action to add the 
	 * home_url filter.
	 *
	 * @return void
	 **/
	public function pre_comment_on_post() {
		add_filter( 'home_url', array( $this, 'home_url' ), null, 2 );
	}

	/**
	 * Hooks the WP home_url action 
	 * 
	 * Hackity hack: this function is attached with add_filter within
	 * the query_vars filter and the pre_comment_on_post action.
	 * @TODO: Can't remember why this is attached like this… investigate.
	 *
	 * @param string $url The URL 
	 * @param string $path The path 
	 * @param string $orig_scheme The original scheme 
	 * @param int $blog_id The ID of the blog 
	 * @return string The URL
	 **/
	public function home_url( $url, $path ) {
		$orig_url = $url;
		// @FIXME: The way I'm working out the home_url, by replacing the path with an empty string; it feels hacky… is it?
		// @FIXME: Do I need to use something multibyte string safe, rather than str_replace?
		if ( '/' != $path && ':' != $path )
			$base_url = str_replace( $path, '', $url );
		else
			$base_url = '';
		$path = ltrim( $path, '/' );
		$url = trailingslashit( $base_url ) . $this->url_prefix . '/' . $path;
		$url = rtrim( $url, '/' );
		return $url;
	}

	/**
	 * Hooks the WP body_class filter to add some language specific classes.
	 *
	 * @param array $classes The body classes 
	 * @return array The body classes 
	 **/
	public function body_class( $classes ) {
		$lang = bbl_get_current_lang();
		$classes[] = 'bbl-' . $lang->text_direction;
		$classes[] = 'bbl-' . $lang->text_direction;
		$classes[] = 'bbl-' . sanitize_title( $lang->names );
		$classes[] = 'bbl-' . sanitize_title( $lang->url_prefix );
		$classes[] = 'bbl-' . sanitize_title( $lang->code );
		$classes[] = 'bbl-' . sanitize_title( $lang->display_name );
		return $classes;
	}

	/**
	 * Hooks the WP post_class filter to add some language specific classes.
	 *
	 * @param array $classes The post classes 
	 * @param array $class One or more classes which have been added to the class list.
	 * @param int $post_id The ID of the post we're providing classes for 
	 * @return array The body classes 
	 **/
	public function post_class( $classes, $class, $post_id ) {
		$post = get_post( $post_id );
		$post_lang_code = bbl_get_post_lang_code( $post );
		$lang = bbl_get_lang( $post_lang_code );
		$classes[] = 'bbl-post-' . $lang->text_direction;
		$classes[] = 'bbl-post-' . sanitize_title( $lang->names );
		$classes[] = 'bbl-post-' . sanitize_title( $lang->url_prefix );
		$classes[] = 'bbl-post-' . sanitize_title( $lang->code );
		$classes[] = 'bbl-post-' . sanitize_title( $lang->display_name );
		return $classes;
	}

	// Public Methods
	// --------------

	/**
	 * Get the current lang for this class, which is also the
	 * current lang in the Query Vars.
	 *
	 * @return void
	 **/
	public function get_lang() {
		return $this->lang;
	}

	/**
	 * Set the current lang for this class, and in Query Vars.
	 *
	 * @param string $lang The language code to switch to 
	 * @return void
	 **/
	public function switch_to_lang( $lang ) {
		// @FIXME: Need to validate language here
		if ( ! is_array( $this->lang_stack ) )
			$this->lang_stack = array();
		$this->lang_stack[] = $this->lang;
		$this->set_lang( $lang );
		set_query_var( 'lang', $this->lang );
	}
	
	/**
	 * Restore the previous lang from the switched stack.
	 *
	 * @return void
	 **/
	public function restore_lang() {
		$this->set_lang( array_pop( $this->lang_stack ) );
		set_query_var( 'lang', $this->lang );
	}

	// Non-public Methods
	// ------------------

	/**
	 * Set the language code and URL prefix for any 
	 * subsequent requests.
	 *
	 * @FIXME: Currently we don't check that the language is valid
	 *
	 * @param string $code A language code
	 * @return void
	 **/
	protected function set_lang( $code ) {
		global $bbl_languages;
		$this->lang = $code;
		$this->url_prefix = $bbl_languages->get_url_prefix_from_code( $this->lang );
	}

	/**
	 * Set the language for the URL prefix provided.
	 *
	 * @param string $url_prefix A URL prefix, e.g. "de" 
	 * @return void
	 **/
	protected function set_lang_from_prefix( $url_prefix ) {
		global $bbl_languages;
		$this->set_lang( bbl_get_lang_from_prefix( $url_prefix ) );
	}

	/**
	 * Get the request string for the request, using code copied 
	 * straight from WP->parse_request.
	 *
	 * @return string The request
	 **/
	protected function get_request_string() {
		global $wp_rewrite;
		// @FIXME: Copying a huge hunk of code from WP->parse_request here, feels ugly.
		// START: Huge hunk of WP->parse_request
		if ( isset($_SERVER['PATH_INFO']) )
			$pathinfo = $_SERVER['PATH_INFO'];
		else
			$pathinfo = '';
		$pathinfo_array = explode('?', $pathinfo);
		$pathinfo = str_replace("%", "%25", $pathinfo_array[0]);
		$req_uri = $_SERVER['REQUEST_URI'];
		$req_uri_array = explode('?', $req_uri);
		$req_uri = $req_uri_array[0];
		$self = $_SERVER['PHP_SELF'];
		$home_path = parse_url(home_url());
		if ( isset($home_path['path']) )
			$home_path = $home_path['path'];
		else
			$home_path = '';
		$home_path = trim($home_path, '/');

		// Trim path info from the end and the leading home path from the
		// front.  For path info requests, this leaves us with the requesting
		// filename, if any.  For 404 requests, this leaves us with the
		// requested permalink.
		$req_uri = str_replace($pathinfo, '', $req_uri);
		$req_uri = trim($req_uri, '/');
		$req_uri = preg_replace("|^$home_path|", '', $req_uri);
		$req_uri = trim($req_uri, '/');
		$pathinfo = trim($pathinfo, '/');
		$pathinfo = preg_replace("|^$home_path|", '', $pathinfo);
		$pathinfo = trim($pathinfo, '/');
		$self = trim($self, '/');
		$self = preg_replace("|^$home_path|", '', $self);
		$self = trim($self, '/');

		// The requested permalink is in $pathinfo for path info requests and
		//  $req_uri for other requests.
		if ( ! empty($pathinfo) && !preg_match('|^.*' . $wp_rewrite->index . '$|', $pathinfo) ) {
			$request = $pathinfo;
		} else {
			// If the request uri is the index, blank it out so that we don't try to match it against a rule.
			if ( $req_uri == $wp_rewrite->index )
				$req_uri = '';
			$request = $req_uri;
		}
		// END: Huge hunk of WP->parse_request
		return $request;
	}

	/**
	 * Checks the DB structure is up to date.
	 *
	 * @return void
	 * @author Simon Wheatley
	 **/
	protected function maybe_update() {
		global $wpdb;
		$option_name = 'bbl-locale-version';
		$version = get_option( $option_name, 0 );

		if ( $this->version == $version )
			return;

		if ( $version < 1 ) {
			error_log( "Babble Locale: Flushing rewrite rules" );
			flush_rewrite_rules();
		}

		error_log( "Babble Locale: Done updates" );
		update_option( $option_name, $this->version );
	}

}

$bbl_locale = new Babble_Locale();

?>